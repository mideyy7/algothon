import time
import numpy as np

# -------------------------
# Payoffs
# -------------------------
def call_payoff(S, K):
    return np.maximum(0.0, S - K)

def put_payoff(S, K):
    return np.maximum(0.0, K - S)

def etf_pack_payoff(S):
    return (
        2.0 * put_payoff(S, 6200.0)
        + 1.0 * call_payoff(S, 6200.0)
        - 2.0 * call_payoff(S, 6600.0)
        + 3.0 * call_payoff(S, 7000.0)
    )

# -------------------------
# Simple models
# -------------------------
class EWMA:
    def __init__(self, alpha=0.05):
        self.alpha = alpha
        self.mu = None
        self.var = None

    def update(self, x):
        x = float(x)
        if self.mu is None:
            self.mu = x
            self.var = 1.0
            return self.mu, np.sqrt(self.var)
        dx = x - self.mu
        self.mu = (1 - self.alpha) * self.mu + self.alpha * x
        self.var = (1 - self.alpha) * self.var + self.alpha * (dx * dx)
        return self.mu, np.sqrt(self.var)

def mc_fair(payoff_fn, mu, sigma, n=40000, seed=7):
    rng = np.random.default_rng(seed)
    sims = rng.normal(mu, max(1e-6, sigma), size=n)
    return float(np.mean(payoff_fn(sims)))

def mc_delta(payoff_fn, mu, sigma, bump=1.0, n=25000, seed=11):
    rng = np.random.default_rng(seed)
    sims = rng.normal(mu, max(1e-6, sigma), size=n)
    up = payoff_fn(sims + bump)
    dn = payoff_fn(sims - bump)
    return float(np.mean((up - dn) / (2.0 * bump)))

# -------------------------
# API adapter (replace)
# -------------------------
class ExchangeAPI:
    def get_mid(self, product):
        raise NotImplementedError

    def get_best_bid_ask(self, product):
        raise NotImplementedError

    def place_order(self, product, side, price, qty):
        raise NotImplementedError

    def get_position(self, product):
        raise NotImplementedError

# -------------------------
# 0) Flatten inventory NOW
# -------------------------
def flatten_all(api: ExchangeAPI, products: list[str], clip=20):
    for p in products:
        pos = api.get_position(p)
        if pos == 0:
            continue
        bid, ask = api.get_best_bid_ask(p)
        qty = int(min(abs(pos), clip))
        if pos > 0:
            api.place_order(p, "SELL", bid, qty)
        if pos < 0:
            api.place_order(p, "BUY", ask, qty)

from collections import deque
import numpy as np
import time

# -------------------------
# Rolling realized vol on ETF
# -------------------------
class RollingRV:
    def __init__(self, n=120):
        self.px = deque(maxlen=n + 1)

    def update(self, p: float) -> float:
        self.px.append(float(p))
        if len(self.px) < 25:
            return np.nan
        r = np.diff(np.log(np.array(self.px)))
        return float(np.sqrt(np.mean(r * r)))

# -------------------------
# Rolling ridge regression fair value:
#   PACK ~ b0 + b1*ETF + b2*ETF^2 + b3*RV
# -------------------------
class RollingRidge:
    def __init__(self, window=700, ridge=5e-2):
        self.X = deque(maxlen=window)
        self.y = deque(maxlen=window)
        self.ridge = ridge
        self.beta = np.zeros(4)

    def add(self, etf: float, rv: float, pack: float):
        if np.isnan(rv):
            return
        x = np.array([1.0, etf, etf * etf, rv], dtype=float)
        self.X.append(x)
        self.y.append(float(pack))

    def fit(self):
        if len(self.y) < 120:
            return self.beta
        X = np.vstack(self.X)
        y = np.array(self.y)
        XtX = X.T @ X
        Xty = X.T @ y
        lam = self.ridge * np.eye(4)
        self.beta = np.linalg.solve(XtX + lam, Xty)
        return self.beta

    def predict(self, etf: float, rv: float) -> float:
        x = np.array([1.0, etf, etf * etf, rv], dtype=float)
        return float(x @ self.beta)

    def dprice_detf(self, etf: float) -> float:
        return float(self.beta[1] + 2.0 * self.beta[2] * etf)

# -------------------------
# Rolling z-score of residual
# -------------------------
class RollingZ:
    def __init__(self, n=350):
        self.r = deque(maxlen=n)

    def add(self, v: float):
        self.r.append(float(v))

    def z(self, v: float) -> float:
        if len(self.r) < 80:
            return np.nan
        arr = np.array(self.r, dtype=float)
        mu = float(arr.mean())
        sd = float(arr.std() + 1e-9)
        return (v - mu) / sd

# -------------------------
# Market 7/8 pure statistical arb
# -------------------------
class ETFPackStatArb:
    def __init__(
        self,
        api,
        etf="LON_ETF",
        pack="ETF_PACK_8",
        max_pack_pos=18,
        max_etf_pos=35,
        clip_pack=3,
        clip_etf=6,
        z_enter=2.5,
        z_exit=0.6,
        cooldown=0.15,
    ):
        self.api = api
        self.etf = etf
        self.pack = pack

        self.max_pack_pos = max_pack_pos
        self.max_etf_pos = max_etf_pos
        self.clip_pack = clip_pack
        self.clip_etf = clip_etf

        self.z_enter = z_enter
        self.z_exit = z_exit
        self.cooldown = cooldown
        self.last_trade = 0.0

        self.rv = RollingRV(n=120)
        self.reg = RollingRidge(window=700, ridge=5e-2)
        self.resid = RollingZ(n=350)

    def flatten_pair(self, clip=10):
        for p in [self.pack, self.etf]:
            pos = self.api.get_position(p)
            if pos == 0:
                continue
            bid, ask = self.api.get_best_bid_ask(p)
            q = int(min(abs(pos), clip))
            if pos > 0:
                self.api.place_order(p, "SELL", bid, q)
            if pos < 0:
                self.api.place_order(p, "BUY", ask, q)

    def step(self):
        etf_mid = self.api.get_mid(self.etf)
        pack_mid = self.api.get_mid(self.pack)

        bid_p, ask_p = self.api.get_best_bid_ask(self.pack)
        bid_e, ask_e = self.api.get_best_bid_ask(self.etf)

        rv = self.rv.update(etf_mid)

        self.reg.add(etf_mid, rv, pack_mid)
        self.reg.fit()

        fair = self.reg.predict(etf_mid, rv)
        r = pack_mid - fair
        self.resid.add(r)
        z = self.resid.z(r)

        pack_pos = self.api.get_position(self.pack)
        etf_pos = self.api.get_position(self.etf)

        now = time.time()
        if now - self.last_trade < self.cooldown:
            return {"act": "COOLDOWN", "z": z, "resid": r, "fair": fair}

        # Exit: spread normalized => flatten (lock in mean reversion)
        if (not np.isnan(z)) and abs(z) < self.z_exit:
            if pack_pos != 0 or etf_pos != 0:
                self.flatten_pair(clip=8)
                self.last_trade = now
                return {"act": "FLATTEN_EXIT", "z": z, "resid": r, "fair": fair}

        if np.isnan(z):
            return {"act": "WARMUP", "z": z, "resid": r, "fair": fair}

        dP_dE = self.reg.dprice_detf(etf_mid)

        # residual high => pack rich => SELL pack + hedge ETF
        if z > self.z_enter:
            room_sell_pack = max(0, self.max_pack_pos + pack_pos)
            if room_sell_pack > 0:
                q_pack = int(min(self.clip_pack, room_sell_pack))
                self.api.place_order(self.pack, "SELL", bid_p, q_pack)

                hedge = int(np.clip(dP_dE * q_pack, -self.clip_etf, self.clip_etf))
                room_buy_etf = max(0, self.max_etf_pos - etf_pos)
                room_sell_etf = max(0, self.max_etf_pos + etf_pos)

                if hedge > 0 and room_buy_etf > 0:
                    self.api.place_order(self.etf, "BUY", ask_e, int(min(hedge, room_buy_etf)))
                if hedge < 0 and room_sell_etf > 0:
                    self.api.place_order(self.etf, "SELL", bid_e, int(min(-hedge, room_sell_etf)))

                self.last_trade = now
                return {"act": f"SELL_PACK {q_pack} HEDGE {hedge}", "z": z, "resid": r, "fair": fair}

        # residual low => pack cheap => BUY pack + hedge ETF
        if z < -self.z_enter:
            room_buy_pack = max(0, self.max_pack_pos - pack_pos)
            if room_buy_pack > 0:
                q_pack = int(min(self.clip_pack, room_buy_pack))
                self.api.place_order(self.pack, "BUY", ask_p, q_pack)

                hedge = int(np.clip(dP_dE * q_pack, -self.clip_etf, self.clip_etf))
                room_buy_etf = max(0, self.max_etf_pos - etf_pos)
                room_sell_etf = max(0, self.max_etf_pos + etf_pos)

                if hedge > 0 and room_sell_etf > 0:
                    self.api.place_order(self.etf, "SELL", bid_e, int(min(hedge, room_sell_etf)))
                if hedge < 0 and room_buy_etf > 0:
                    self.api.place_order(self.etf, "BUY", ask_e, int(min(-hedge, room_buy_etf)))

                self.last_trade = now
                return {"act": f"BUY_PACK {q_pack} HEDGE {hedge}", "z": z, "resid": r, "fair": fair}

        return {"act": "HOLD", "z": z, "resid": r, "fair": fair}

# -------------------------
# Replace your run_regime() with this:
# -------------------------
def run_stat_arb_78(api: ExchangeAPI):
    ETF = "LON_ETF"      # Market 7
    PACK = "ETF_PACK_8"  # Market 8 (change if your symbol differs)

    strat = ETFPackStatArb(
        api=api,
        etf=ETF,
        pack=PACK,
        max_pack_pos=18,
        max_etf_pos=35,
        clip_pack=3,
        clip_etf=6,
        z_enter=2.5,
        z_exit=0.6,
        cooldown=0.15,
    )

    # Flatten ONLY these two (do NOT flatten all markets if you want to keep other bots)
    for _ in range(6):
        strat.flatten_pair(clip=12)
        time.sleep(0.2)

    while True:
        strat.step()
        time.sleep(0.15)
