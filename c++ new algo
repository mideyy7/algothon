#include <bits/stdc++.h>
using namespace std;

struct Fill {
  long long ts;          // unix ms
  string product;
  int side;              // +1 buy, -1 sell
  double price;
  double qty;
};

static inline long long parse_unix_ms(const string& s) {
  // If your timestamp is already unix ms, just stoll(s).
  // Otherwise, pre-convert timestamps to unix ms in export step.
  return stoll(s);
}

static vector<string> split_csv_line(const string& line) {
  vector<string> out;
  string cur;
  bool inq = false;
  for(char c: line){
    if(c=='"'){ inq=!inq; continue; }
    if(c==',' && !inq){ out.push_back(cur); cur.clear(); }
    else cur.push_back(c);
  }
  out.push_back(cur);
  return out;
}

int main(int argc, char** argv) {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);

  string mids_path = "mid_prices.csv";
  string fills_path = "fills.csv";
  string driver = "LON_ETF";
  int lookback = 120;

  // ---------- load mids ----------
  ifstream fm(mids_path);
  string header;
  getline(fm, header);
  auto cols = split_csv_line(header);

  int ncol = (int)cols.size();
  unordered_map<string,int> col_id;
  for(int i=0;i<ncol;i++) col_id[cols[i]] = i;

  vector<long long> ts;
  vector<vector<double>> mids; // mids[t][j]
  string line;
  while(getline(fm, line)){
    if(line.empty()) continue;
    auto f = split_csv_line(line);
    ts.push_back(parse_unix_ms(f[0]));
    vector<double> row(ncol-1, 0.0);
    for(int j=1;j<ncol;j++){
      row[j-1] = f[j].empty() ? NAN : stod(f[j]);
    }
    mids.push_back(move(row));
  }
  int T = (int)ts.size();

  auto mid_at = [&](int t, const string& prod)->double{
    auto it = col_id.find(prod);
    if(it==col_id.end()) return NAN;
    int j = it->second - 1;
    if(j<0 || j>=ncol-1) return NAN;
    return mids[t][j];
  };

  // ---------- load fills ----------
  ifstream ff(fills_path);
  getline(ff, header);
  vector<Fill> fills;
  while(getline(ff, line)){
    if(line.empty()) continue;
    auto f = split_csv_line(line);
    Fill x;
    x.ts = parse_unix_ms(f[0]);
    x.product = f[1];
    string side = f[2];
    for(auto &c: side) c = toupper(c);
    x.side = (side=="BUY") ? +1 : -1;
    x.price = stod(f[3]);
    x.qty = stod(f[4]);
    fills.push_back(move(x));
  }
  sort(fills.begin(), fills.end(), [](const Fill& a, const Fill& b){ return a.ts < b.ts; });

  // ---------- products universe from mids header ----------
  vector<string> products;
  for(int i=1;i<ncol;i++) products.push_back(cols[i]);

  unordered_map<string,int> pid;
  for(int i=0;i<(int)products.size();i++) pid[products[i]] = i;

  vector<double> pos(products.size(), 0.0);
  double cash = 0.0;

  // index fills by time (two pointer)
  int fi = 0, F = (int)fills.size();

  vector<double> equity(T, 0.0), pnl(T, 0.0), peak(T, 0.0), dd(T, 0.0);

  // ---------- regime (bull/bear) from driver lookback return ----------
  vector<int> regime(T, 0); // +1 bull, -1 bear, 0 unknown
  {
    vector<double> px(T, NAN);
    for(int t=0;t<T;t++) px[t] = mid_at(t, driver);
    for(int t=lookback;t<T;t++){
      if(isnan(px[t]) || isnan(px[t-lookback]) || px[t-lookback]==0.0) continue;
      double rr = (px[t]/px[t-lookback]) - 1.0;
      regime[t] = (rr>0.0) ? +1 : -1;
    }
  }

  // ---------- simulate ----------
  for(int t=0;t<T;t++){
    long long cur = ts[t];

    while(fi<F && fills[fi].ts==cur){
      const auto& x = fills[fi];
      auto it = pid.find(x.product);
      if(it != pid.end()){
        int k = it->second;
        pos[k] += x.side * x.qty;
        cash -= (x.side * x.qty * x.price);
      }
      fi++;
    }

    double gross = 0.0;
    for(int k=0;k<(int)products.size();k++){
      double m = mid_at(t, products[k]);
      if(!isnan(m)) gross += pos[k] * m;
    }
    equity[t] = cash + gross;
    pnl[t] = equity[t] - equity[0];
    peak[t] = (t==0) ? equity[t] : max(peak[t-1], equity[t]);
    dd[t] = equity[t] - peak[t];
  }

  auto summarize = [&](const vector<int>& mask){
    double eq0 = NAN, eq1 = NAN;
    double maxdd = 0.0;
    double last = NAN;
    int n = 0;

    for(int t=0;t<T;t++){
      if(!mask[t]) continue;
      if(isnan(eq0)) eq0 = equity[t];
      eq1 = equity[t];
      maxdd = min(maxdd, dd[t]);
      last = equity[t];
      n++;
    }
    cout << "n=" << n;
    if(n>0){
      cout << " pnl=" << (eq1 - eq0);
      cout << " maxdd=" << maxdd;
    }
    cout << "\n";
  };

  vector<int> all(T,1), bull(T,0), bear(T,0);
  for(int t=0;t<T;t++){
    bull[t] = (regime[t]==+1);
    bear[t] = (regime[t]==-1);
  }

  cout << "ALL:  "; summarize(all);
  cout << "BULL: "; summarize(bull);
  cout << "BEAR: "; summarize(bear);

  return 0;
}
